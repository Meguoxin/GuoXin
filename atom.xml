<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WordGuo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-17T11:51:03.488Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郭三金</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android AsyncTask</title>
    <link href="http://yoursite.com/2017/10/17/Android-AsyncTask/"/>
    <id>http://yoursite.com/2017/10/17/Android-AsyncTask/</id>
    <published>2017-10-17T11:50:05.000Z</published>
    <updated>2017-10-17T11:51:03.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于Asnynck有很多的源码解读，但一些解读现在看来已经不在适用了，比如AsyncTask类必须在UI Thread当中加载，AsyncTask的对象必须在UI Thread当中实例化等一些结论都是基于以前版本的代码来解读的，现在看来已经不是这样的了。同时分析了在AsyncTask的使用中存在的以及以及应该注意的问题，基于一些实际存在的问题尤其是并行串行问题，写了一个类似AsyncTask的库AsyncTaskScheduler，处理了上述的一些实际存在的问题。转载自<a href="https://silencedut.github.io" target="_blank" rel="external">@SilenceDut</a> 的博客</p></blockquote><a id="more"></a><!-- toc --><h3 id="AsyncTask源码解读"><a href="#AsyncTask源码解读" class="headerlink" title="AsyncTask源码解读"></a>AsyncTask源码解读</h3><font size="4" style="font-weight: bold;">一些结论解读（基于android-23源码）：</font><br><font style="font-weight: bold;">1. API 16 以前必须在主线程加载 AsyncTask，API 16 以后就不用了。</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><br>因为<font style="font-weight: bold;">AsyncTask</font>主要目的是在后台执行异步任务，然后和<font style="font-weight: bold;">UI</font>线程进行交互，所以需要得到<font style="font-weight: bold;">UI</font>线程的<font style="font-weight: bold;">Handler</font>，之前的<font style="font-weight: bold;">AsyncTask</font>加载时，是得到当前加载线程的<font style="font-weight: bold;">Handler</font>，而最新的源码中，总是得到<font style="font-weight: bold;">UI</font>线程的<font style="font-weight: bold;">Looper</font>来创建和<font style="font-weight: bold;">UI</font>交互的<font style="font-weight: bold;">Handler</font><p><font style="font-weight: bold;">2.</font>因为每个<font style="font-weight: bold;">AsyncTask</font>只能执行一次，多次调用同一个<font style="font-weight: bold;">AsyncTask</font>对象会出现异常。但如果要处理多个后台任务，你需要创建多个<font style="font-weight: bold;">AsyncTask</font>并执行<font style="font-weight: bold;">execute()</font>。<font style="font-weight: bold;">AsyncTask</font>有三种状态，就绪<font style="font-weight: bold;">PENDING</font>，运行<font style="font-weight: bold;">RUNNING</font>,结束<font style="font-weight: bold;">FINISHED</font>,只有<font style="font-weight: bold;">PENDING(就绪状态)</font>的可以正确执行,执行后将状态置为<font style="font-weight: bold;">Running</font>,可知，每个<font style="font-weight: bold;">AsyncTask</font>只能执行一次，所有要想执行多个异步任务，只能新建多个<font style="font-weight: bold;">AsyncTask</font>对象。<br></p><p><font style="font-weight: bold;">3.</font> API 4-11 默认是AsnckTask任务并发执行，API11后默认是顺序执行，任务是顺序执行，必须等一个任务结束才能执行下一个。但是可以通过executeOnExecutor（AsyncTask.THREAD_POOL_EXECUTOR）来进行并行执行任务，在并行执行任务时，<font style="font-weight: bold;">有最大执行个数的限制THREAD_POOL _EXECUTOR是默认的并行执行任务的线程池，BlockingQueue队列的长度是128。以自己的8核手机为例，其核心线程数是9个，最大线程是17，所能最大加入的任务数是128+17=145</font>，如果超出这个任务数，就会报出RejectExecutionException异常（经过测试）。</p><p><font style="font-weight: bold;">4.</font><font style="font-weight: bold;">AsyncTask</font>需要在UI线程调用execute()函数调用execute()函数时调用了<font style="font-weight: bold;">onPreExecute()</font>，而<font style="font-weight: bold;">onPreExecute()</font>需要在UI线程中执行，所以<font style="font-weight: bold;">AsyncTask</font>需要在UI线程调用execute()函数 。（但是如果你不适用<font style="font-weight: bold;">onPreExecute</font>在主线程做一些操作的话，<font style="font-weight: bold;">execute()</font>可以在任意线程调用）<br><!-- toc --></p><h3 id="AsyncTask执行任务的过程原理"><a href="#AsyncTask执行任务的过程原理" class="headerlink" title="AsyncTask执行任务的过程原理"></a>AsyncTask执行任务的过程原理</h3><p>提取核心部分，简化后的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">Result result = doInBackground(mParams);</div><div class="line">Binder.flushPendingCommands();</div><div class="line"><span class="keyword">return</span> postResult(result);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">    </div><div class="line">    postResultIfNotInvoked(get());</div><div class="line">    </div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><font style="font-weight: bold;">AsyncTask</font>的任务执行原理是新建一个有返回值的任务线程<font style="font-weight: bold;">FuntureTask</font>和一个<font style="font-weight: bold;">Callabler</font>任务<font style="font-weight: bold;">WorkerRunnable</font>，在任务中从<font style="font-weight: bold;">doInBackground</font>得到的结果<font style="font-weight: bold;">Result</font>通过<font style="font-weight: bold;">Handler</font>进行处理，调用<font style="font-weight: bold;">onProgress</font>和<font style="font-weight: bold;">onPostResult(Result result)</font><a href="http://www.silencedut.com/2016/06/15/Callable%E5%92%8CFuture%E3%80%81FutureTask%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">关于Future FutureTask Callable的使用</a><br><!-- toc --></p><h3 id="AsyncTask的黑暗面"><a href="#AsyncTask的黑暗面" class="headerlink" title="AsyncTask的黑暗面"></a>AsyncTask的黑暗面</h3><blockquote><p>如果搜索关键词”AsyncTask的缺陷”，会有很多关于AsyncTask缺陷的文章，很多是基于以下几个问题，但这些问题真的是AsyncTask自身的问题还是使用不当导致的呢?这真的需要好好分析一下，不能人云亦云，强行甩锅。</p></blockquote><p><font size="5" style="font-weight: bold;">使用不当带来的问题</font> </p><p><font style="font-weight: bold;">1. 生命周期和内存泄漏</font><br>“当Activity结束或者退出应用时AsyncTask会一直执行doInBackground()方法直到方法执行结束，这可能会导致在onPostExecute时view不存在而导致崩溃溃，以及可能的内存泄露”。<br>如果退出Activity时AsyncTask扔在执行，上面说的的却会发生，但这些问题需要由使用者来解决而不是AsyncTask来解决，因为AsyncTask只是执行后台任务，它怎么知道你什么时候要终止，要退出，确定使用Handler时不会出现这样问题？？？<br><img src="http://pic.qqtn.com/up/2016-4/2016042810230577962.jpg" alt="avatar"></p><p><font style="font-weight: bold;">2. cancel不能正常取消的问题</font><br>首先调用cancel终止AsyncTask的原理是对执行异步任务的线程调用interrupt()函数。每个线程内部都有一个boolean型变量表示线程的中断状态，true代表线程处于中断状态，false表示未处于中断状态。<br>而interrupt()方法的作用只是用来改变线程的中断状态(把线程的中断状态改为true,即被中断)。Thread.interrupt()只在Object.wait() .Object.join(), Object.sleep()几个方法会主动抛出InterruptedException异常，从而结束阻塞状态。而在其他的时候，只是通过设置了Thread的一个标志位信息，需要程序自我进行处理。</p><p>所以如果你的AsyncTask后台任务有未做中断的处理肯定会一直执行这个线程。所以这需要你自己在doInbackground里进行中断处理，即使你认为这是个缺陷也应该是Thread类的缺陷，因为要用到线程处理异步任务，AsyncTask无法选择其他方式，而且调用cancel后onPostExecute也不会在执行了，不会导致UI线程的问题，所以这个锅也不应该AsyncTask来背。</p><p><font style="font-weight: bold;">3. Activity意外重启，状态消失问题</font><br>比如当用户旋转屏幕的时候Activity就会重新启动，如果之前有AsyncTask正在异步加载处理数据，那么之前的数据就会消失，而新的AsyncTask重新创建，这的却是个问题，但你用其他的方式进行请求同样会发生这个问题啊。</p><p>其实可能是我们的要求太多了，AsyncTask只是一个处理异步任务的工具，很多逻辑上的东西需要我们自己来处理，就像使用Handler和Thread，不正确处理同样会出现上述问题，这些总得来说就是异步带来的问题，这是一个时间和性能的选择问题，AsyncTask就是简化了包装了Handler的处理步骤而已。上面的这些更应该是一些重要的注意事项，而不是AsyncTask的问题</p><p><font size="5" style="font-weight: bold;">实际存在的问题</font> </p><p><font style="font-weight: bold;">1. 并行串行问题</font><br>上面的一些可能是由于使用不当导致的，但并行串行问题方面AsyncTask问题很大。看AsyncTask源码文档时看到这样建议”AsyncTasks should ideally be used for short operations (a few seconds at the most”，就是尽量执行一个短时间的任务，最对也就几秒的任务。当初还很疑惑，AsyncTask这玩意不就是用来处理后台任务的吗，又不是在主线程，为什么还限制短时间的任务，那要你何用啊。<br><img src="http://ww3.sinaimg.cn/large/006tKfTcgw1f79jvx6kmzj307v07274o.jpg" alt="avatar"><br>上面分析过在api11后AsyncTask默认的是串行执行任务，基本现上市面上的设备上都将是串行执行。自己可以写个Demo试试看。</p><p>这些串行执行共用的AsyncTask的是一个线程池，这真的很严重。因为是顺序执行，导致你调用execute() 可能 没法立刻执行，也可能就执行不了，因为谁知道有没有其他的AsyncTask任务在执行啊，或者任务还是个很耗时的任务，或者就是个while(ture)循环或者for(;;)来一直处理一种后台任务，那么同一进程内的AsyncTask在这之后调用execute的都将无法执行。</p><p>想当初初学Android时觉得AsyncTask真是个方便的东西，手机写了个基于socket通信的应用，doInbackground处理，然后直接通知UI。在doInbackground函数里处理一些连接以及数据流的接收及发送，socket的等待连接和数据结束都是阻塞的啊，现在回想起来当初真是年轻😃。</p><p>当然你可以立刻执行一个任务通过调用executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)通过AsyncTask的THREAD_POOL_EXECUTOR线程池或者传入其他的线程池来立刻执行任务，但THREAD_POOL_EXECUTOR有最大并发数的限制，但只执行一个任务时通过线程池来管理的也是无奈之举，而且这种方式不是默认方案啊，不容易发现啊。</p><p><font style="font-weight: bold;">2. 错误处理问题</font><br>AsyncTask没有对发生的一些异常进行处理，你只能在onBackground里进行一些判断，但之外的一些异常情况发生你都无法了解，比如线程异常退出等。</p><p><font style="font-weight: bold;">3. 多个任务的管理问题</font><br>如果需要多个后台任务，需要新建多个AsyncTask来执行任务，在需要退出的时候你需要对每一个都进行一定的处理来避免内存泄露以及UI问题，这是一个很麻烦的事情。</p><p><font style="font-weight: bold;"><br>如果你使用AsyncTask默认的执行方式，出了问题都很难排查。你可以保证你能正确使用AsyncTask，但你没法保证别人也能正确使用啊，这就是别人给你挖的坑，但是你跳了进去啊，关键你可能都不知道到底哪个AsyncTask在执行，可能引用就发生在第三方库的也有可能啊。</font><br><!-- toc --></p><h3 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h3><p>基于上述实际存在的问题尤其是并行串行问题，写了一个类似AsyncTask的库AsyncTaskScheduler，处理了上述的一些实际存在的问题。</p><p><font style="font-weight: bold;" size="4">特点</font></p><p><ul><br>    <li>默认多个任务并行处理。</li><br>    <li>执行单个任务无需使用线程池。</li><br>    <li>支持自定义线程池。</li><br>    <li>支持错误处。</li><br>    <li>多个任务的管理管理方便。</li><br>    <li>支持任何线程处使用，结果都会在UI线程处理。</li><br></ul></p><p><font style="font-weight: bold;" size="4">方法介绍</font></p><p><ul><br>    <li>doInBackground</li><br>    <li>onProgressUpdate</li><br>    <li>onExecuteSucceed</li><br>    <li>onExecuteCancelled</li><br>    <li>onExecuteFailed。</li><br></ul></p><p><font style="font-weight: bold;" size="4">使用</font><br>1.单个任务——是在单个线程里执行，不需要线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">SingleAsyncTask singleTask = <span class="keyword">new</span> SingleAsyncTask&lt;Void,String&gt;() &#123;   </div><div class="line">    <span class="meta">@Override</span>    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doInBackground</span><span class="params">()</span> </span>&#123;   </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;   </div><div class="line">    &#125;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExecuteSucceed</span><span class="params">(String result)</span> </span>&#123;      </div><div class="line">       <span class="keyword">super</span>.onExecuteSucceed(result);      </div><div class="line">   &#125;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExecuteFailed</span><span class="params">(Exception exception)</span> </span>&#123;      </div><div class="line">       <span class="keyword">super</span>.onExecuteFailed(exception);    </div><div class="line">       Log.i(TAG,<span class="string">"onExecuteCancelled:"</span>+exception.getMessage()+Thread.currentThread());</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">singleTask.executeSingle();</div><div class="line"><span class="comment">//取消通过executeSingle执行的任务</span></div><div class="line"> mSingleAsyncTask.cancel(<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p><p>2.多个任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//多个任务新建一个任务调度器</span></div><div class="line">AsyncTaskScheduler mAsyncTaskScheduler = <span class="keyword">new</span> AsyncTaskScheduler();</div><div class="line">SingleAsyncTask singleTask1 = <span class="keyword">new</span>  SingleTask() &#123; ... &#125;；</div><div class="line">SingleAsyncTask singleTask2 = <span class="keyword">new</span>  SingleTask() &#123; ... &#125;；</div><div class="line">SingleAsyncTask singleTask3 = <span class="keyword">new</span>  SingleTask() &#123; ... &#125;；</div><div class="line">...</div><div class="line"><span class="comment">//并行执行多个任务</span></div><div class="line">mAsyncTaskScheduler.execute(singleTask1)</div><div class="line">.execute(singleTask2).execute(singleTask3).</div><div class="line"><span class="comment">//设置默认的线程池</span></div><div class="line">Executor defaultPoolExecutor = ...</div><div class="line">AsyncTaskScheduler mAsyncTaskScheduler = <span class="keyword">new</span> AsyncTaskScheduler(Executor defaultPoolExecutor);</div><div class="line"> <span class="comment">//取消通过AsyncTaskScheduler任务</span></div><div class="line">mAsyncTaskScheduler.cancelAllTasks(<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p><p>3.确保正确的取消任务以防止避免内存泄露或其他问题</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;关于Asnynck有很多的源码解读，但一些解读现在看来已经不在适用了，比如AsyncTask类必须在UI Thread当中加载，AsyncTask的对象必须在UI Thread当中实例化等一些结论都是基于以前版本的代码来解读的，现在看来已经不是这样的了。同时分析了在AsyncTask的使用中存在的以及以及应该注意的问题，基于一些实际存在的问题尤其是并行串行问题，写了一个类似AsyncTask的库AsyncTaskScheduler，处理了上述的一些实际存在的问题。转载自&lt;a href=&quot;https://silencedut.github.io&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@SilenceDut&lt;/a&gt; 的博客&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android sound code" scheme="http://yoursite.com/tags/Android-sound-code/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 的各种集合的线线程</title>
    <link href="http://yoursite.com/2017/10/16/Java-Thread/"/>
    <id>http://yoursite.com/2017/10/16/Java-Thread/</id>
    <published>2017-10-16T13:15:56.000Z</published>
    <updated>2017-10-17T10:25:23.769Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h3 id="一-线程安全"><a href="#一-线程安全" class="headerlink" title="一. 线程安全"></a>一. 线程安全</h3><p>首先要明白线程的工作原理，jvm有一个main memory，而每个线程有自己的working memory一个线程对一个variable进行操作时，都要在自己的workingmemory里面建立一个copy，操作完之后再写入mainmemory。<a id="more"></a>多个线程同时操作同一个variable，就可能会出现不可预知的结果。根据上面的解释，很容易想出相应的scenario。而用synchronized的关键是建立一个monitor，这个monitor可以是要修改的variable也可以其他你认为合适的object比如method，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完load到workingmemory －&gt; use&amp;assign －&gt; store到mainmemory的过程，才会释放它得到的锁。这样就实现了所谓的线程安全。什么是线程安全?线程安全是怎么完成的(原理)? 线程安全就是说多线程访问同一代码，不会产生不确定的结果。编写线程安全的代码是低依靠线程同步。<br><!-- toc --></p><h3 id="二-JAVA-相关的集合"><a href="#二-JAVA-相关的集合" class="headerlink" title="二. JAVA 相关的集合"></a>二. JAVA 相关的集合</h3><p>Vector、ArrayList、LinkedList<br>Vector和ArrayList在使用上非常相似,都可用来表示一组数量可变的对象应用的集合,并且可以随机地访问其中的元素。<br>Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。</p><font size="3" style="font-weight: bold;">ArrayList和LinkedList区别</font><p>对于处理一列数据项,Java提供了两个类ArrayList和LinkedList,ArrayList的内部实现是基于内部数组Object[],所以从概念上讲,它更象数组，但LinkedList的内部实现是基于一组连接的记录,所以,它更象一个链表结构，所以,它们在性能上有很大的差别。<br>从上面的分析可知,在ArrayList的前面或中间插入数据时,你必须将其后的所有数据相应的后移,这样必然要花费较多时间，所以,当你的操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能而访问链表中的某个元素时,就必须从链表的一端开始沿着连接方向一个一个元素地去查找,直到找到所需的元素为止，所以,当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。如果在编程中,1，2两种情形交替出现,这时,你可以考虑使用List这样的通用接口,而不用关心具体的实现，在具体的情形下,它的性能由具体的实现来保证。</p><font size="4" style="font-weight: bold;">TreeSet,TreeMap</font><br><font size="3" style="font-weight: bold;">TreeSet：</font><p>1、TreeSet基于TreeMap实现，支持排序。</p><p>2、TreeSet是非线程安全的。<br>从对HashSet和TreeSet的描述来看，TreeSet和HashSet一样，也是完全基于Map来实现的，并且都不支持get(int)来获取指定位置的元素（需要遍历获取），另外TreeSet还提供了一些排序方面的支持。例如传入Comparator实现、descendingSet以及descendingIterator等。</p><p><font size="3" style="font-weight: bold;">TreeMap：</font><br>1、TreeMap是一个典型的基于红黑树的Map实现，因此它要求一定要有Key比较的方法，要么传入Comparator实现，要么key对象实现Comparable接口。<br>2、TreeMap是非线程安全的。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h3 id=&quot;一-线程安全&quot;&gt;&lt;a href=&quot;#一-线程安全&quot; class=&quot;headerlink&quot; title=&quot;一. 线程安全&quot;&gt;&lt;/a&gt;一. 线程安全&lt;/h3&gt;&lt;p&gt;首先要明白线程的工作原理，jvm有一个main memory，而每个线程有自己的working memory一个线程对一个variable进行操作时，都要在自己的workingmemory里面建立一个copy，操作完之后再写入mainmemory。
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java-Thread-theory" scheme="http://yoursite.com/tags/Java-Thread-theory/"/>
    
  </entry>
  
  <entry>
    <title>Android面试一天一题</title>
    <link href="http://yoursite.com/2017/10/16/Android-interview/"/>
    <id>http://yoursite.com/2017/10/16/Android-interview/</id>
    <published>2017-10-16T10:02:59.000Z</published>
    <updated>2017-10-16T12:12:51.331Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h3 id="Android-面试启示录"><a href="#Android-面试启示录" class="headerlink" title="Android 面试启示录"></a>Android 面试启示录</h3><center><br><a href="http://www.jianshu.com/p/7a7db9f8692d" target="_blank" rel="external">Day1<br>知道Service吗，它有几种启动方式？</a><br></center><br><a id="more"></a><br><center><br><a href="http://www.jianshu.com/p/df7af437e766" target="_blank" rel="external">Day2<br>用广播来更新UI界面好吗？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/ae6e1d93cc8e" target="_blank" rel="external">Day3<br>怎么理解Activity的生命周期？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/f8a0c43b3dfe" target="_blank" rel="external">Day4<br>如何判断Activity是否在运行？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/1071b9c48f1e" target="_blank" rel="external">Day5<br>自定义View的状态是如何保存的？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/4f482548de59" target="_blank" rel="external">Day6<br>通过new创建的View实例它的onSaveStateInstance会被调用吗？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/c0c5e0540928" target="_blank" rel="external">Day7<br>Java的值传递和引用传递问题</a><br></center><br><center><br><a href="http://www.jianshu.com/p/108db0240a34" target="_blank" rel="external">Day8<br>能讲讲Android的Handler机制吗？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/be593134eeae" target="_blank" rel="external">Day9<br>两个Activity之间如何传递参数？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/0754e65a5744e" target="_blank" rel="external">Day10<br>如何理解Android中的Context，它有什么用？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/8fd5fa90ee6c" target="_blank" rel="external">Day11<br>如何优化ListView的性能？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/024f46834485" target="_blank" rel="external">Day12<br>如何实现应用内多语言切换？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/c925b3ea1444" target="_blank" rel="external">Day13<br>在项目中使用AsyncTask会有什么问题吗？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/4dd53e1be5ba" target="_blank" rel="external">Day14<br>修改SharedPreferences后两种提交方式有什么区别？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/380231307070" target="_blank" rel="external">Day15<br>有使用过ContentProvider码？能说说Android为什么要设计ContentProvider这个组件吗？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/fd70d652f9e3" target="_blank" rel="external">Day16<br>如何处理线程同步的问题？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/a354af5cd6d1" target="_blank" rel="external">吹牛题</a><br></center><br><center><br><a href="http://www.jianshu.com/p/3178e527ec76" target="_blank" rel="external">Day17<br>做一个完整的项目，提交到github。</a><br></center><br><center><br><a href="http://www.jianshu.com/p/3ca780defc93" target="_blank" rel="external">如何准备自我介绍</a><br></center><br><center><br><a href="http://www.jianshu.com/p/2398aad3bd61" target="_blank" rel="external">Day18<br>如何对SQLite数据库中进行大量的数据插入？</a><br></center><br><center><br><a href="http://www.jianshu.com/p/cb5c4e5598ed" target="_blank" rel="external">Day 19<br>程序员何苦为难程序员（上）</a><br></center><br><center><br><a href="http://www.jianshu.com/p/be85f1f4f67f" target="_blank" rel="external">如何与HR谈薪资</a><br></center><br><center><br><a href="http://www.jianshu.com/p/e466b6390a7c" target="_blank" rel="external">Day 20<br>程序员何苦为难程序员（下）</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/heiDbziXa5Qqz_wT8AHfqg" target="_blank" rel="external">Day21<br>res目录一细节处见真章</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/fNava715FfxgUBZfiLM63g" target="_blank" rel="external">Day22<br>图片到底是什么</a><br></center><br><center><br><a href="https://mp.weixin.qq.com/s/bHnpkjQAcapQ_MBnih_Z2w" target="_blank" rel="external">Day23<br>当Android遇上JavaScript</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/8cuee9KR8yNkZacXQLOmBg" target="_blank" rel="external">Day24<br>悲催的Fragment</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/cCQCewGjOB42lEOEu_Eb8g" target="_blank" rel="external">Day25<br>进程和线程</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/EOWeMczrCQ3sy5671jr-fQ" target="_blank" rel="external">Day26<br>ScrollView嵌套ListView的事件冲突</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/A6Gxf86eyClR6Eul6rHF-Q" target="_blank" rel="external">Day27<br>ART&amp;Dalvik</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/5Oq697huPaqeRvWYkeXKnQ" target="_blank" rel="external">Day28<br>内存泥潭（上）</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/3rrTyC2KINh838bHYgGwSA" target="_blank" rel="external">Day29<br>内存泥潭（下）</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/XMi7s7_AXlVI73baOlCtZQ" target="_blank" rel="external">Day30<br>老外自定义View面试题</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/KBsdd55-VDOCPuxFms3sRA" target="_blank" rel="external">Day31<br>Android技术难题解决方案</a><br></center><br><center><br><a href="https://mp.weixin.qq.com/s/Iiz8v-V31OKIMGRpL2vf7g" target="_blank" rel="external">Day32<br>谈谈使用过的第三方开源库</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/ye32wAFo3RB8w1pWVLen_A" target="_blank" rel="external">Day33<br>Android开发的套路MVP&amp;MVVM</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/loBn6lOoluKO9a4pPAVTRg" target="_blank" rel="external">Day34<br>常用的Android相关站点</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/TLajuvyK75Om49gjdTp9IA" target="_blank" rel="external">Day35<br>神秘的Binder机制</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/6I2Z7yYQIRR0RXyBwS4Zfg" target="_blank" rel="external">Day36<br>AIDL</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/yhlTdkDE86tlxNxo8OIWjQ" target="_blank" rel="external">Day37<br>一套高级工程师的面试题</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/BkKLbySeCgOKIBZr1X1ZDg" target="_blank" rel="external">Day38<br>如何设计一个照片上传App</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/gd1DJ2hi-cm_NTCC0GxMgg" target="_blank" rel="external">Day39<br>写博客重要嘛？</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/9-XaISWgoaJPyLe0r72lvw" target="_blank" rel="external">Day40<br>标配Rxjava+Retrofit+OkHttp该怎么面？</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/9yuF3ayfyFM5apD_8TTXGA" target="_blank" rel="external">Day41<br>一波面试官准备Kotlin面试题</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/-BoCv8RZZYJCN0yT5rPHxw" target="_blank" rel="external">Day42<br>关于Android布局你不知道的</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/XG6N8V9qXGZh1y5k0-doqg" target="_blank" rel="external">Day43<br>设计模式</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/_8JOIbEjHHz-UmFD6HnlOQ" target="_blank" rel="external">Day44<br>实战美团-java内存模型</a><br></center><br><center><br><a href="http://mp.weixin.qq.com/s/H4FhhCKb9wqVUVoHuRh0YQ" target="_blank" rel="external">Day45<br>实战锤子科技-线程引发的问题</a><br></center><!-- toc --><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><center><a href="https://github.com/Mr-YangCheng/ForAndroidInterview" target="_blank" rel="external"><font size="4" style="font-weight: bold;">Android 名企面试题及涉及知识点整理。</font></a></center>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;h3 id=&quot;Android-面试启示录&quot;&gt;&lt;a href=&quot;#Android-面试启示录&quot; class=&quot;headerlink&quot; title=&quot;Android 面试启示录&quot;&gt;&lt;/a&gt;Android 面试启示录&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/7a7db9f8692d&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Day1&lt;br&gt;知道Service吗，它有几种启动方式？&lt;/a&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android Interview" scheme="http://yoursite.com/tags/Android-Interview/"/>
    
  </entry>
  
  <entry>
    <title>曾经打架的兄弟，现在和我不再联系</title>
    <link href="http://yoursite.com/2017/10/16/feeling/"/>
    <id>http://yoursite.com/2017/10/16/feeling/</id>
    <published>2017-10-16T05:08:32.000Z</published>
    <updated>2017-10-16T12:19:08.146Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/4286313-2878861948574b11?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="avatar" title="图片来源:电影《心灵捕手》"><br><a id="more"></a></p><p><blockquote class="blockquote-center">第01节</blockquote><br>强哥是我最铁的兄弟，现在在德州开了几家扒鸡店。</p><p>前段时间，强哥给我打电话说：“老三，我下周四结婚，你得来当伴郎。”</p><p>那段时间我正处于低谷期。稿子写的不够好，业务上也被同事碾压，不敢放松一分一秒，也不好意思请假。</p><p>我对着电话支支吾吾地说，强哥我可能去不了。后来强哥说，孙涛从美国都飞回来了，咱们兄弟3个好久不见了，你能试着请假吗？<br>我打开电脑看了一下文章的排期表，周三那天正好排的是我的稿子。我想了想还是说，工作这边太忙不能去。然后我忙补充一句，强哥，我就不去了，礼金我让他们捎过去。他语气一下就变了，声音忽然变得很低：“我又不是为了要你的钱，他在美国读书，你在北京工作，我们三兄弟好久没聚齐过了。”</p><font style="font-weight: bold;">后来我也没去。我安慰自己，都是兄弟，他可以担待的。</font><br><blockquote class="blockquote-center">第02节</blockquote><br>结婚以后第四个月强哥带着媳妇来北京旅游，给我打电话说来北京玩上3天。强哥说好久不见我了，想喊着我一块吃个饭，还带了一点东西给我。我说没问题，你们两口子来北京了，我怎么都得好好招呼招呼你们。<br><br>强哥来的那天是星期四，那天我们公号要定月度计划，到家的时候差不多是凌晨3点了。我躺在床上想让他们两口子这两天好好玩玩，第三天周六的时候我再去找他们。<br><br>周五下午，本来之前订好去参加的一个新媒体交流活动的主办方给我们打电话说，活动的档期改到了这个周六。让我们尽量早晨九点之前到。<br><br>那个下午我给强哥打电话说，我这里忽然有个急事，不能陪他了。强哥说没事没事，以后机会多的是。当时特别愧疚。我在心里安慰自己，都是兄弟，他可以担待的。<br><br>4个月后我刷朋友圈的时候，看到了强哥晒的孩子满月照片，我才知道强哥刚办完满月酒。我越想越难受，晚上的时候给强哥打了一个电话，问他怎么没叫我。强哥说，他感觉我比较忙，处于事业上升期，应该全身心地发展事业。让我不要多心。再说又不止要这一个，下次二胎的时候叫我。<br><br><font style="font-weight: bold;">强哥和我打电话的时候还是嘻嘻哈哈的，但不知道为什么我感觉我们之间的感情越来越远了。后来慢慢的有点疏远了，强哥也不给我点赞了，也很少在我们的那个小群里吹牛了。</font><br><blockquote class="blockquote-center">第03节</blockquote><br>因为这件事心情特别不好，周末躺在床上两天。因为我知道“都是兄弟，他一定可以担待一些的”这句话已经安慰不了我了。<br><br>那时候我模糊而清晰地发觉我和强哥之间的关系有了一个难以修补的裂缝，一条不可逾越的鸿沟。<br><br>星期一上班的时候我起晚了，去上班的时候路过一个初中，他们穿着蓝白相间的校服，男生们三五成群地在斑马线上走着，像极了初中时的我们。<br><br>我想起了初一那年的我们。初一刚开学我和强哥一个班，当时还不是特别熟。我被几个社会上的混混勒索收保护费的时候我没给他们。结果有一天放学，7、8个混混一起在学校门口堵我，几个人把我拉到学校旁边的小树林，说要打到我听话为止。<br><br>那天强哥正好路过，走到我前面，看了我一眼说：“别慌，有我呢。”<br><br>转过头跟着混混说，几个兄弟，我是跟西关东哥混的，我兄弟得罪你们的话我给你赔礼道歉，今天给我个面子放我兄弟一马。<br><br>说完不等混混回应就转过身来朝着我咧嘴笑，转身就要带着我走。<br><br>我在那里不敢动。他说你愣着干啥，我这都摆平了，找个地方请我吃饭去吧。他话音刚落几个混混就把棍子抡到强哥身上了，边砸边喊，你是个什么东西，还给你面子。我连忙上前护住强哥。<br><br>就这样我和强哥都被人揍了。被揍得鼻青脸肿。晚上的时候我和强哥在学校附近的一个烧烤摊，拿着身上仅剩的50块钱，要了一盘水煮花生，和几瓶酒。我们一人端着一瓶燕京，碰完以后，看着对方的像猪头一样的脸傻笑，然后一饮而尽。<br><br><font style="font-weight: bold;">那时候我就感觉强哥会是我一辈子的兄弟。</font><br><blockquote class="blockquote-center">第04节</blockquote><br>那天我没去上班，我给主管发了一个请假的短信。还没等她回复我就迫不及待地买了去德州的动车票，我想去找强哥当面说清，我不想失去强哥这样一个兄弟。<br><br>两点多到了德州站，我想着给强哥一个惊喜，就没打电话让他来接。出了高铁站按照强哥经常在朋友圈定位的地名打了一个出租车，上车坐了15分钟还没到。我记得上次强哥说从他家到高铁站只要5分钟。<br><br>我以为是司机故意绕路宰我，我拿出手机地图输了强哥家小区的名字，屏幕上显示从高铁站到小区有28.5km。<br><br>我想起了16年底12月中旬的时候，晚上9:00我从济南坐动车去北京，中间经停德州，大概停五分钟，那天我发朋友圈说自己又要去北京了。强哥在下面评论：“我们好久不见了，不然你在德州停的时候我去找你吧。反正高铁站离我家不远开车五分钟。”<br><br>到了德州停车的时候，我刚出动车门就看见强哥在那里等着。那天特别冷，我穿着一个加厚版的大衣都冻的难受。<br><br>强哥左手提着两盒扒鸡，右手拿着一盒烟，看见我下车就赶紧递给我，这是你以前最喜欢抽的白将军，天冷抽颗暖暖身子吧。那天一根烟刚抽了2/3，动车即将关门的广播就响了，我拿着强哥给的扒鸡上车了。<br><br>现在看了地图我才知道，原来强哥说的不远是28.5km，说的开车5分钟的路程，其实要走上1小时。<br><br>晚上九点多零下十几度的天气，28.5km的距离，1个多小时的车程，来换了我2/3根烟的时间。<br><br>当时的心情特别复杂，既后悔又愧疚，强哥对我这么好，我却因为各种事错过他的婚礼，错过了他人生中最大的几件事。<br><br><font style="font-weight: bold;">错过了他跪着拿着戒指对新娘求婚，错过了当他生命中仅此一次伴郎的机会，错过了他端起酒杯对着宾朋满座感谢他们的到来和支持的时候，错过了他为人父的举起女儿的时刻。</font><p>在车上我就哭了。我感觉特对不起强哥。司机从后视镜里看见在后座上哭的我，递给了我几张纸巾，用一种过来人的口气说，孩子，你还小，不值得为女人这么伤心。然后把音乐换成了《爱情买卖》。司机把我逗笑了。</p><p>那天晚上到了强哥的家，强哥看到我先是惊讶，后来很平静地走了过来把我的包拿过来放下，然后用力拍了拍我的肩膀说，兄弟，你来了。</p><font style="font-weight: bold;">晚上，我和强哥各自拿了一瓶啤酒，碰瓶，一饮而尽。像极了初一那年的那个晚上我们俩鼻青脸肿地在烧烤摊端起酒杯的时候。</font><br><blockquote class="blockquote-center">第05节</blockquote><br>人这一辈子大概有26298天，631152小时。在这漫长的岁月里我们会接触数万人，99.999%的人都是我们生命里的过客。真正的好兄弟，无话不谈的朋友只有很少的0.001%，然而这极其难得的0.001%，我们都极少去珍惜。<br><br>因为，在我们眼里他们是我们的兄弟，无论我们做了什么，他们都不会有一点点介意。我们可以不用照顾他们的任何感受。<br><br>曾经我以为是兄弟就可以肆无忌惮，嘴上说我是把你当兄弟才这样对你，才可以放你的鸽子，才可以没有任何心理负担地拒绝你。<br><br>但其实他们也会介意，也会难过，也会失望。友情就像是爱情一样都需要经营，都需要付出，都需要嘘寒问暖。<br><br><font style="font-weight: bold;">我们总是把自己最差最不堪的一面给了我们最亲切，漫长岁月里只遇见0.001%的人。把最好的脾气，最好的礼貌给了我们生命里的99.999%的过客。</font><font style="font-weight: bold;">我们总是想讨全世界的欢心，除了我们生命里最重要的那0.001%。</font><p>PS:国庆假期马上结束，无论你在哪，无论你在干什么，都希望你能给你那个重要的兄弟发个消息，打个电话，最好的话就是兄弟几个见个面撸个串喝点酒，吹吹牛逼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4286313-2878861948574b11?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;avatar&quot; title=&quot;图片来源:电影《心灵捕手》&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Feeling" scheme="http://yoursite.com/categories/Feeling/"/>
    
    
      <category term="time and tide" scheme="http://yoursite.com/tags/time-and-tide/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/15/Hello-World/"/>
    <id>http://yoursite.com/2017/10/15/Hello-World/</id>
    <published>2017-10-15T12:03:04.000Z</published>
    <updated>2017-10-16T00:43:24.406Z</updated>
    
    <content type="html"><![CDATA[<center>This is my first blog</center><br><center>Helle World!</center><br><a id="more"></a><br><center>My Name is GuoXin.</center>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;This is my first blog&lt;/center&gt;&lt;br&gt;&lt;center&gt;Helle World!&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="tags" scheme="http://yoursite.com/tags/tags/"/>
    
  </entry>
  
</feed>
